<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>옷마카세 | 아바타 생성/조절 데모</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#070a12; }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-columns: minmax(300px, 360px) 1fr; }

    #panel {
      color:#e6e9f2;
      padding:14px;
      overflow:auto;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    }

    .top { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom: 10px; }
    #panel h2 { margin: 0; font-size: 14px; letter-spacing: -0.2px; }
    #panel .hint { margin: 8px 0 12px; font-size: 12px; color: rgba(230,233,242,0.78); line-height: 1.55; }

    .section-title{ margin: 14px 0 8px; font-size: 12px; font-weight: 800; color: rgba(230,233,242,0.92); letter-spacing: -0.2px; }
    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex: 1; }

    .field { display:grid; gap:6px; margin-bottom: 10px; }
    label { font-size: 12px; color: rgba(230,233,242,0.85); }

    input[type="text"], input[type="number"]{
      width: 100%; box-sizing: border-box;
      padding: 10px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color:#e6e9f2; outline:none;
    }
    input:focus { border-color: rgba(255,255,255,0.25); }

    input[type="range"]{ width:100%; accent-color: #ffb020; }

    .kv { display:flex; align-items:center; justify-content:space-between; gap:10px; font-size: 12px; color: rgba(230,233,242,0.75); margin-top: 6px; }

    .actions { display:flex; gap:10px; margin-top: 10px; }
    button {
      flex:1; padding:10px 12px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.10);
      color:#e6e9f2; cursor:pointer; font-weight: 800;
    }
    button:hover { background: rgba(255,255,255,0.14); }
    button.primary { border-color: rgba(255,176,32,0.25); background: rgba(255,176,32,0.12); }

    .small { font-size: 11px; color: rgba(230,233,242,0.62); line-height: 1.5; margin-top: 10px; }

    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size: 12px; color: rgba(230,233,242,0.85);
      white-space: nowrap;
    }

    #view { position: relative; }
    canvas { display:block; width:100%; height:100%; }

    .badge {
      position:absolute; left: 12px; bottom: 12px;
      padding: 8px 10px; border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.85);
      font-size: 12px;
      backdrop-filter: blur(8px);
    }
    .status {
      position:absolute; right: 12px; top: 12px;
      padding: 8px 10px; border-radius: 12px;
      background: rgba(0,0,0,0.50);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      backdrop-filter: blur(8px);
      max-width: min(560px, calc(100% - 24px));
      line-height: 1.45;
    }
    .status b { color: #ffcf6a; }
    .status code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      color: rgba(255,255,255,0.90);
      background: rgba(255,255,255,0.08);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.10);
    }

    @media (max-width: 860px) {
      #wrap { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      #panel { border-right: none; border-bottom: 1px solid rgba(255,255,255,0.08); }
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="panel">
    <div class="top">
      <div>
        <h2>아바타 불러오기 & 길이/비율 조절</h2>
        <p class="hint">
          GLB(스켈레톤 포함) 아바타를 불러온 뒤, 슬라이더로 키/팔/다리/몸통/어깨폭/골반폭을 조절합니다.<br/>
          드래그: 회전 / 휠: 확대·축소
        </p>
      </div>
      <div class="pill" id="pillState">대기</div>
    </div>

    <div class="section-title">1) 아바타 로드</div>
    <div class="field">
      <label>기본 경로 (이 페이지 기준 상대경로로 자동 계산)</label>
      <div class="row">
        <input id="modelUrl" type="text" value="" />
        <button id="btnLoad" class="primary">로드</button>
      </div>
      <div class="kv">
        <span>또는 파일 선택으로 즉시 로드</span>
        <input id="filePick" type="file" accept=".glb,.gltf" style="max-width:180px;" />
      </div>
    </div>

    <div class="section-title">2) 길이/비율 조절</div>

    <div class="field">
      <label>전체 크기(Uniform Scale)</label>
      <input id="S_all" type="range" min="0.80" max="1.20" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_all_v">1.00</span></div>
    </div>

    <div class="field">
      <label>몸통 길이(Spine/Chest)</label>
      <input id="S_torso" type="range" min="0.85" max="1.20" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_torso_v">1.00</span></div>
    </div>

    <div class="field">
      <label>다리 길이(UpperLeg/LowerLeg)</label>
      <input id="S_leg" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_leg_v">1.00</span></div>
    </div>

    <div class="field">
      <label>팔 길이(UpperArm/LowerArm)</label>
      <input id="S_arm" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_arm_v">1.00</span></div>
    </div>

    <div class="field">
      <label>어깨 폭(좌/우 UpperArm 위치)</label>
      <input id="S_shoulderW" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_shoulderW_v">1.00</span></div>
    </div>

    <div class="field">
      <label>골반 폭(좌/우 UpperLeg 위치)</label>
      <input id="S_hipW" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_hipW_v">1.00</span></div>
    </div>

    <div class="actions">
      <button id="btnReset">리셋</button>
      <button id="btnSave">설정 저장</button>
    </div>

    <div class="actions">
      <button id="btnLoadCfg">설정 불러오기</button>
      <input id="cfgPick" type="file" accept=".json" style="flex:1; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,0.14); background:rgba(255,255,255,0.06); color:#e6e9f2;" />
    </div>

    <div class="small">
      주의: 아바타 파일마다 본(뼈) 이름이 다를 수 있습니다. 본 자동 탐지를 했지만,
      탐지가 안 되면 우측 상단 상태창에 “어떤 본을 못 찾았다”가 표시됩니다.
    </div>
  </div>

  <div id="view">
    <div class="status" id="status"><b>상태:</b> 초기화 중...</div>
    <div class="badge">Ootmakase | Avatar Adjust</div>
    <canvas id="c"></canvas>
  </div>
</div>

<script type="module">
  // 중요: "three" 같은 bare specifier를 쓰면 GitHub Pages에서 바로 실패합니다.
  // 아래처럼 CDN 절대 URL로만 import해야 합니다.
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
  import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

  const $ = (id)=> document.getElementById(id);

  // (핵심) fitting/ 기준 상대경로 → 절대 URL로 자동 계산
  const DEFAULT_MODEL_URL = new URL("./assets/avatar.glb", location.href).toString();
  $("modelUrl").value = DEFAULT_MODEL_URL;

  const statusEl = $("status");
  const pillState = $("pillState");
  const setStatus = (html)=> statusEl.innerHTML = html;
  const setPill = (txt)=> pillState.textContent = txt;

  const sliderIds = ["S_all","S_torso","S_leg","S_arm","S_shoulderW","S_hipW"];
  function syncSliderLabels(){
    for (const id of sliderIds){
      $(id+"_v").textContent = Number($(id).value).toFixed(2);
    }
  }
  syncSliderLabels();

  // ---------- three scene ----------
  const canvas = $("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x070a12);

  const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
  camera.position.set(1.7, 1.3, 2.6);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x223355, 0.9));
  const key = new THREE.DirectionalLight(0xffffff, 1.15);
  key.position.set(2.8, 5.0, 2.2);
  key.castShadow = true;
  key.shadow.mapSize.set(2048, 2048);
  scene.add(key);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(30, 30),
    new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness: 1, metalness: 0 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // ---------- avatar state ----------
  let modelGroup = null;
  let skinnedRoot = null;
  let skeleton = null;
  let bones = {};

  const base = {
    groupScale: new THREE.Vector3(1,1,1),
    bonePos: new Map(),
    boneScale: new Map(),
  };

  const normalizeName = (s)=> (s||"").toLowerCase().replaceAll(" ", "").replaceAll("_","").replaceAll("-","");
  function findBoneByAliases(aliases){
    if (!skeleton) return null;
    const aliasSet = aliases.map(normalizeName);

    for (const b of skeleton.bones){
      const n = normalizeName(b.name);
      if (aliasSet.includes(n)) return b;
    }
    for (const b of skeleton.bones){
      const n = normalizeName(b.name);
      for (const a of aliasSet){
        if (n.includes(a)) return b;
      }
    }
    return null;
  }

  function captureBaseTransforms(){
    base.groupScale.copy(modelGroup.scale);
    base.bonePos.clear();
    base.boneScale.clear();
    skeleton.bones.forEach(b=>{
      base.bonePos.set(b.uuid, b.position.clone());
      base.boneScale.set(b.uuid, b.scale.clone());
    });
  }

  function restoreBaseTransforms(){
    if (!modelGroup || !skeleton) return;
    modelGroup.scale.copy(base.groupScale);
    skeleton.bones.forEach(b=>{
      const p = base.bonePos.get(b.uuid);
      const s = base.boneScale.get(b.uuid);
      if (p) b.position.copy(p);
      if (s) b.scale.copy(s);
    });
  }

  function scaleChildOffset(parentBone, childBone, factor){
    if (!parentBone || !childBone) return;
    const orig = base.bonePos.get(childBone.uuid);
    if (!orig) return;
    childBone.position.copy(orig).multiplyScalar(factor);
  }
  function scaleBoneXOffset(bone, factor){
    if (!bone) return;
    const orig = base.bonePos.get(bone.uuid);
    if (!orig) return;
    bone.position.set(orig.x * factor, orig.y, orig.z);
  }

  function mapBones(){
    bones = {};
    bones.hips   = findBoneByAliases(["hips","pelvis","j_bip_c_hips","mixamorighips"]);
    bones.spine  = findBoneByAliases(["spine","j_bip_c_spine","mixamorigspine"]);
    bones.chest  = findBoneByAliases(["spine2","chest","upperchest","j_bip_c_chest","mixamorigspine2","mixamorigchest"]);
    bones.neck   = findBoneByAliases(["neck","j_bip_c_neck","mixamorigneck"]);
    bones.head   = findBoneByAliases(["head","j_bip_c_head","mixamorighead"]);

    bones.lUpperArm = findBoneByAliases(["leftupperarm","l_upperarm","j_bip_l_upperarm","mixamorigleftupperarm","mixamorigleftarm"]);
    bones.lLowerArm = findBoneByAliases(["leftlowerarm","l_lowerarm","j_bip_l_lowerarm","mixamorigleftlowerarm","mixamorigleftforearm"]);
    bones.lHand     = findBoneByAliases(["lefthand","l_hand","j_bip_l_hand","mixamoriglefthand"]);

    bones.rUpperArm = findBoneByAliases(["rightupperarm","r_upperarm","j_bip_r_upperarm","mixamorigrighupperarm","mixamorigrightupperarm","mixamorigrightarm"]);
    bones.rLowerArm = findBoneByAliases(["rightlowerarm","r_lowerarm","j_bip_r_lowerarm","mixamorigrightlowerarm","mixamorigrightforearm"]);
    bones.rHand     = findBoneByAliases(["righthand","r_hand","j_bip_r_hand","mixamorigrighthand"]);

    bones.lUpperLeg = findBoneByAliases(["leftupperleg","l_upperleg","j_bip_l_upperleg","mixamorigleftupleg"]);
    bones.lLowerLeg = findBoneByAliases(["leftlowerleg","l_lowerleg","j_bip_l_lowerleg","mixamorigleftleg"]);
    bones.lFoot     = findBoneByAliases(["leftfoot","l_foot","j_bip_l_foot","mixamorigleftfoot"]);

    bones.rUpperLeg = findBoneByAliases(["rightupperleg","r_upperleg","j_bip_r_upperleg","mixamorigrightupleg"]);
    bones.rLowerLeg = findBoneByAliases(["rightlowerleg","r_lowerleg","j_bip_r_lowerleg","mixamorigrightleg"]);
    bones.rFoot     = findBoneByAliases(["rightfoot","r_foot","j_bip_r_foot","mixamorigrightfoot"]);

    const must = [
      ["hips","hips"], ["spine","spine"], ["chest","chest"],
      ["lUpperArm","L upperArm"], ["lLowerArm","L lowerArm"],
      ["rUpperArm","R upperArm"], ["rLowerArm","R lowerArm"],
      ["lUpperLeg","L upperLeg"], ["lLowerLeg","L lowerLeg"],
      ["rUpperLeg","R upperLeg"], ["rLowerLeg","R lowerLeg"],
    ];
    const missing = must.filter(([k])=> !bones[k]).map(([,label])=> label);

    let msg = `<b>상태:</b> 아바타 로드 완료<br/>`;
    msg += `<b>로드 경로:</b> <code>${$("modelUrl").value}</code><br/>`;
    msg += `<b>스켈레톤:</b> ${skeleton?.bones?.length ?? 0} bones 탐지<br/>`;
    if (missing.length){
      msg += `<b>경고:</b> 일부 본 탐지 실패 → <span style="color:#ff8a8a;">${missing.join(", ")}</span><br/>`;
      msg += `<span style="color:rgba(255,255,255,0.72)">본 이름이 특이한 모델이면 매핑을 조정해야 합니다.</span>`;
      setPill("부분 동작");
    } else {
      msg += `<b>OK:</b> 주요 본 탐지 성공 (길이/폭 조절 가능)`;
      setPill("정상");
    }
    setStatus(msg);
  }

  function applyAdjust(){
    if (!modelGroup || !skeleton) return;

    restoreBaseTransforms();

    const sAll = Number($("S_all").value);
    const sTorso = Number($("S_torso").value);
    const sLeg = Number($("S_leg").value);
    const sArm = Number($("S_arm").value);
    const sShoulderW = Number($("S_shoulderW").value);
    const sHipW = Number($("S_hipW").value);

    modelGroup.scale.set(sAll, sAll, sAll);

    if (bones.spine && bones.chest) scaleChildOffset(bones.spine, bones.chest, sTorso);
    else if (bones.hips && bones.spine) scaleChildOffset(bones.hips, bones.spine, sTorso);
    if (bones.chest && bones.neck) scaleChildOffset(bones.chest, bones.neck, sTorso);
    if (bones.neck && bones.head)  scaleChildOffset(bones.neck, bones.head, sTorso);

    if (bones.lUpperLeg && bones.lLowerLeg) scaleChildOffset(bones.lUpperLeg, bones.lLowerLeg, sLeg);
    if (bones.lLowerLeg && bones.lFoot)     scaleChildOffset(bones.lLowerLeg, bones.lFoot, sLeg);
    if (bones.rUpperLeg && bones.rLowerLeg) scaleChildOffset(bones.rUpperLeg, bones.rLowerLeg, sLeg);
    if (bones.rLowerLeg && bones.rFoot)     scaleChildOffset(bones.rLowerLeg, bones.rFoot, sLeg);

    if (bones.lUpperArm && bones.lLowerArm) scaleChildOffset(bones.lUpperArm, bones.lLowerArm, sArm);
    if (bones.lLowerArm && bones.lHand)     scaleChildOffset(bones.lLowerArm, bones.lHand, sArm);
    if (bones.rUpperArm && bones.rLowerArm) scaleChildOffset(bones.rUpperArm, bones.rLowerArm, sArm);
    if (bones.rLowerArm && bones.rHand)     scaleChildOffset(bones.rLowerArm, bones.rHand, sArm);

    if (bones.lUpperArm) scaleBoneXOffset(bones.lUpperArm, sShoulderW);
    if (bones.rUpperArm) scaleBoneXOffset(bones.rUpperArm, sShoulderW);
    if (bones.lUpperLeg) scaleBoneXOffset(bones.lUpperLeg, sHipW);
    if (bones.rUpperLeg) scaleBoneXOffset(bones.rUpperLeg, sHipW);
  }

  // ---------- load model ----------
  const loader = new GLTFLoader();

  function clearCurrentModel(){
    if (!modelGroup) return;
    scene.remove(modelGroup);
    modelGroup.traverse(o=>{
      if (o.isMesh){
        if (o.geometry) o.geometry.dispose();
        if (Array.isArray(o.material)) o.material.forEach(m=> m.dispose && m.dispose());
        else if (o.material) o.material.dispose && m.dispose();
      }
    });
    modelGroup = null;
    skinnedRoot = null;
    skeleton = null;
    bones = {};
  }

  function findFirstSkinnedMesh(root){
    let found = null;
    root.traverse(o=>{
      if (!found && o.isSkinnedMesh && o.skeleton) found = o;
    });
    return found;
  }

  function setupShadows(root){
    root.traverse(o=>{
      if (o.isMesh){
        o.castShadow = true;
        o.receiveShadow = false;
      }
    });
  }

  function frameCameraToModel(root){
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box.getSize(size);
    box.getCenter(center);

    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim * 1.8;

    camera.position.set(center.x + dist*0.65, center.y + dist*0.55, center.z + dist*0.85);
    controls.target.copy(center.add(new THREE.Vector3(0, maxDim*0.15, 0)));
    controls.update();
  }

  async function loadFromUrl(url){
    try{
      setPill("로딩중");
      setStatus(`<b>상태:</b> 로딩중...<br/><b>요청 URL:</b> <code>${url}</code>`);

      clearCurrentModel();

      const gltf = await loader.loadAsync(url);
      modelGroup = gltf.scene || gltf.scenes?.[0];
      if (!modelGroup) throw new Error("gltf.scene is empty");

      setupShadows(modelGroup);
      scene.add(modelGroup);

      skinnedRoot = findFirstSkinnedMesh(modelGroup);
      if (!skinnedRoot || !skinnedRoot.skeleton){
        setPill("주의");
        setStatus(
          `<b>상태:</b> 모델 로드 완료<br/>
           <b>경고:</b> SkinnedMesh(스켈레톤)를 찾지 못했습니다.<br/>
           이 기능은 “스켈레톤 포함 GLB”에서만 동작합니다.`
        );
        frameCameraToModel(modelGroup);
        return;
      }

      skeleton = skinnedRoot.skeleton;
      captureBaseTransforms();
      mapBones();
      frameCameraToModel(modelGroup);

      applyAdjust();

    }catch(err){
      console.error(err);
      setPill("실패");
      setStatus(
        `<b>상태:</b> 로드 실패<br/>
         <span style="color:#ff8a8a">${String(err?.message || err)}</span><br/>
         <span style="color:rgba(255,255,255,0.72)">경로가 <code>/assets/...</code>로 시작하면 실패합니다. <code>./assets/avatar.glb</code>를 사용하세요.</span>`
      );
    }
  }

  // ---------- events ----------
  $("btnLoad").addEventListener("click", ()=>{
    const raw = $("modelUrl").value.trim();
    if (!raw) return;

    // "/assets/..." 같은 루트경로면 자동 교정
    let url = raw;
    if (raw.startsWith("/assets/")) {
      url = DEFAULT_MODEL_URL;
      $("modelUrl").value = url;
    } else {
      url = new URL(raw, location.href).toString();
    }
    loadFromUrl(url);
  });

  $("filePick").addEventListener("change", (e)=>{
    const f = e.target.files?.[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    $("modelUrl").value = "(file) " + f.name;
    loadFromUrl(url);
  });

  $("btnReset").addEventListener("click", ()=>{
    $("S_all").value = 1.00;
    $("S_torso").value = 1.00;
    $("S_leg").value = 1.00;
    $("S_arm").value = 1.00;
    $("S_shoulderW").value = 1.00;
    $("S_hipW").value = 1.00;
    syncSliderLabels();
    applyAdjust();
  });

  let tick = null;
  for (const id of sliderIds){
    $(id).addEventListener("input", ()=>{
      syncSliderLabels();
      clearTimeout(tick);
      tick = setTimeout(()=> applyAdjust(), 20);
    });
  }

  // ---------- render loop ----------
  function resize(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  addEventListener("resize", resize);

  function loop(){
    requestAnimationFrame(loop);
    resize();
    controls.update();
    renderer.render(scene, camera);
  }
  loop();

  // boot
  setPill("대기");
  setStatus(`<b>상태:</b> 준비 완료<br/><b>기본 아바타 URL:</b> <code>${DEFAULT_MODEL_URL}</code><br/>상단의 <b>로드</b>를 누르세요.`);
  loadFromUrl(DEFAULT_MODEL_URL);
</script>
</body>
</html>
