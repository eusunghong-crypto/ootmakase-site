<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>옷마카세 | 아바타 생성/조절 데모</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#070a12; }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-columns: minmax(300px, 360px) 1fr; }

    #panel {
      color:#e6e9f2;
      padding:14px;
      overflow:auto;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    }

    .top {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }

    #panel h2 { margin: 0; font-size: 14px; letter-spacing: -0.2px; }
    #panel .hint {
      margin: 8px 0 12px;
      font-size: 12px;
      color: rgba(230,233,242,0.78);
      line-height: 1.55;
    }

    .section-title{
      margin: 14px 0 8px;
      font-size: 12px;
      font-weight: 800;
      color: rgba(230,233,242,0.92);
      letter-spacing: -0.2px;
    }

    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex: 1; }

    .field { display:grid; gap:6px; margin-bottom: 10px; }
    label { font-size: 12px; color: rgba(230,233,242,0.85); }

    input[type="text"], input[type="number"]{
      width: 100%; box-sizing: border-box;
      padding: 10px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color:#e6e9f2; outline:none;
    }
    input:focus { border-color: rgba(255,255,255,0.25); }

    input[type="range"]{
      width:100%;
      accent-color: #ffb020;
    }

    .kv {
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; font-size: 12px;
      color: rgba(230,233,242,0.75);
      margin-top: 6px;
    }

    .actions { display:flex; gap:10px; margin-top: 10px; }
    button {
      flex:1; padding:10px 12px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.10);
      color:#e6e9f2; cursor:pointer; font-weight: 800;
    }
    button:hover { background: rgba(255,255,255,0.14); }
    button.primary {
      border-color: rgba(255,176,32,0.25);
      background: rgba(255,176,32,0.12);
    }

    .small {
      font-size: 11px;
      color: rgba(230,233,242,0.62);
      line-height: 1.5;
      margin-top: 10px;
    }

    .pill {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      color: rgba(230,233,242,0.85);
      white-space: nowrap;
    }

    #view { position: relative; }
    canvas { display:block; width:100%; height:100%; }

    .badge {
      position:absolute; left: 12px; bottom: 12px;
      padding: 8px 10px; border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.85);
      font-size: 12px;
      backdrop-filter: blur(8px);
    }
    .status {
      position:absolute; right: 12px; top: 12px;
      padding: 8px 10px; border-radius: 12px;
      background: rgba(0,0,0,0.50);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      backdrop-filter: blur(8px);
      max-width: min(520px, calc(100% - 24px));
    }
    .status b { color: #ffcf6a; }

    @media (max-width: 860px) {
      #wrap { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      #panel { border-right: none; border-bottom: 1px solid rgba(255,255,255,0.08); }
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="panel">
    <div class="top">
      <div>
        <h2>아바타 불러오기 & 길이/비율 조절</h2>
        <p class="hint">
          GLB(스켈레톤 포함) 아바타를 불러온 뒤, 슬라이더로 키/팔/다리/몸통/어깨폭/골반폭을 조절합니다.<br/>
          드래그: 회전 / 휠: 확대·축소
        </p>
      </div>
      <div class="pill" id="pillState">대기</div>
    </div>

    <div class="section-title">1) 아바타 로드</div>
    <div class="field">
      <label>기본 경로 (프로젝트에 파일 넣고 경로만 맞추면 됨)</label>
      <div class="row">
        <input id="modelUrl" type="text" value="./assets/avatar.glb" />
        <button id="btnLoad" class="primary">로드</button>
      </div>
      <div class="kv">
        <span>또는 파일 선택으로 즉시 로드</span>
        <input id="filePick" type="file" accept=".glb,.gltf" style="max-width:180px;" />
      </div>
    </div>

    <div class="section-title">2) 길이/비율 조절</div>

    <div class="field">
      <label>전체 크기(Uniform Scale)</label>
      <input id="S_all" type="range" min="0.80" max="1.20" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_all_v">1.00</span></div>
    </div>

    <div class="field">
      <label>몸통 길이(Spine/Chest)</label>
      <input id="S_torso" type="range" min="0.85" max="1.20" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_torso_v">1.00</span></div>
    </div>

    <div class="field">
      <label>다리 길이(UpperLeg/LowerLeg)</label>
      <input id="S_leg" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_leg_v">1.00</span></div>
    </div>

    <div class="field">
      <label>팔 길이(UpperArm/LowerArm)</label>
      <input id="S_arm" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_arm_v">1.00</span></div>
    </div>

    <div class="field">
      <label>어깨 폭(좌/우 UpperArm 위치)</label>
      <input id="S_shoulderW" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_shoulderW_v">1.00</span></div>
    </div>

    <div class="field">
      <label>골반 폭(좌/우 UpperLeg 위치)</label>
      <input id="S_hipW" type="range" min="0.85" max="1.25" step="0.01" value="1.00" />
      <div class="kv"><span>값</span><span id="S_hipW_v">1.00</span></div>
    </div>

    <div class="actions">
      <button id="btnReset">리셋</button>
      <button id="btnSave">설정 저장</button>
    </div>

    <div class="actions">
      <button id="btnLoadCfg">설정 불러오기</button>
      <input id="cfgPick" type="file" accept=".json" style="flex:1; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,0.14); background:rgba(255,255,255,0.06); color:#e6e9f2;" />
    </div>

    <div class="small">
      주의: 아바타 파일마다 본(뼈) 이름이 다를 수 있습니다. 본 자동 탐지를 했지만,
      탐지가 안 되면 우측 상단 상태창에 “어떤 본을 못 찾았다”가 표시됩니다.
      (Mixamo / VRM / RPM 계열은 대부분 동작합니다.)
    </div>
  </div>

  <div id="view">
    <div class="status" id="status">
      <b>상태:</b> 아직 아바타가 로드되지 않았습니다.
    </div>
    <div class="badge">Ootmakase | Avatar Adjust</div>
    <canvas id="c"></canvas>
  </div>
</div>

<script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
  import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

  // ---------- Basic three ----------
  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x070a12);

  const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
  camera.position.set(1.7, 1.3, 2.6);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x223355, 0.9));
  const key = new THREE.DirectionalLight(0xffffff, 1.15);
  key.position.set(2.8, 5.0, 2.2);
  key.castShadow = true;
  key.shadow.mapSize.set(2048, 2048);
  scene.add(key);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(30, 30),
    new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness: 1, metalness: 0 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // ---------- UI helpers ----------
  const $ = (id)=> document.getElementById(id);
  const statusEl = $("status");
  const pillState = $("pillState");

  function setStatus(html){
    statusEl.innerHTML = html;
  }
  function setPill(text){
    pillState.textContent = text;
  }

  const sliderIds = ["S_all","S_torso","S_leg","S_arm","S_shoulderW","S_hipW"];
  function syncSliderLabels(){
    for (const id of sliderIds){
      $(id+"_v").textContent = Number($(id).value).toFixed(2);
    }
  }
  syncSliderLabels();

  // ---------- Avatar state ----------
  let modelGroup = null;         // gltf.scene
  let skinnedRoot = null;        // a SkinnedMesh (one of them)
  let skeleton = null;           // skeleton from skinned mesh
  let bones = {};                // mapped bones
  let base = {                   // original transforms
    groupScale: new THREE.Vector3(1,1,1),
    bonePos: new Map(),          // bone.uuid -> Vector3 clone
    boneScale: new Map(),        // bone.uuid -> Vector3 clone
  };

  // try to find by multiple aliases
  const normalizeName = (s)=> (s||"").toLowerCase().replaceAll(" ", "").replaceAll("_","").replaceAll("-","");

  function findBoneByAliases(aliases){
    if (!skeleton) return null;
    const aliasSet = aliases.map(normalizeName);
    for (const b of skeleton.bones){
      const n = normalizeName(b.name);
      if (aliasSet.includes(n)) return b;
    }
    // partial match fallback
    for (const b of skeleton.bones){
      const n = normalizeName(b.name);
      for (const a of aliasSet){
        if (n.includes(a)) return b;
      }
    }
    return null;
  }

  function captureBaseTransforms(){
    base.groupScale.copy(modelGroup.scale);
    base.bonePos.clear();
    base.boneScale.clear();
    skeleton.bones.forEach(b=>{
      base.bonePos.set(b.uuid, b.position.clone());
      base.boneScale.set(b.uuid, b.scale.clone());
    });
  }

  function restoreBaseTransforms(){
    if (!modelGroup || !skeleton) return;
    modelGroup.scale.copy(base.groupScale);
    skeleton.bones.forEach(b=>{
      const p = base.bonePos.get(b.uuid);
      const s = base.boneScale.get(b.uuid);
      if (p) b.position.copy(p);
      if (s) b.scale.copy(s);
    });
  }

  // For "length" we scale the child offset vector (more stable than bone.scale for mixed rigs)
  function scaleChildOffset(parentBone, childBone, factor){
    if (!parentBone || !childBone) return;
    const orig = base.bonePos.get(childBone.uuid);
    if (!orig) return;
    childBone.position.copy(orig).multiplyScalar(factor);
  }

  // Shoulder/hip width: scale X offset of left/right bones from base
  function scaleBoneXOffset(bone, factor){
    if (!bone) return;
    const orig = base.bonePos.get(bone.uuid);
    if (!orig) return;
    bone.position.set(orig.x * factor, orig.y, orig.z);
  }

  // Map common rigs (Mixamo / VRM / RPM-ish)
  function mapBones(){
    bones = {};

    bones.hips   = findBoneByAliases(["hips", "mixamorighips", "j_bip_c_hips", "pelvis"]);
    bones.spine  = findBoneByAliases(["spine", "mixamorigspine", "j_bip_c_spine"]);
    bones.chest  = findBoneByAliases(["spine2","chest","upperchest","mixamorigspine2","mixamorigchest","j_bip_c_chest"]);

    bones.neck   = findBoneByAliases(["neck","mixamorigneck","j_bip_c_neck"]);
    bones.head   = findBoneByAliases(["head","mixamorighead","j_bip_c_head"]);

    bones.lUpperArm = findBoneByAliases(["leftupperarm","l_upperarm","mixamorigleftarm","mixamorigleftupperarm","j_bip_l_upperarm","leftarm"]);
    bones.lLowerArm = findBoneByAliases(["leftlowerarm","l_lowerarm","mixamorigleftforearm","mixamorigleftlowerarm","j_bip_l_lowerarm","leftforearm"]);
    bones.lHand     = findBoneByAliases(["lefthand","l_hand","mixamoriglefthand","j_bip_l_hand"]);

    bones.rUpperArm = findBoneByAliases(["rightupperarm","r_upperarm","mixamorigrightarm","mixamorigrightupperarm","j_bip_r_upperarm","rightarm"]);
    bones.rLowerArm = findBoneByAliases(["rightlowerarm","r_lowerarm","mixamorigrightforearm","mixamorigrightlowerarm","j_bip_r_lowerarm","rightforearm"]);
    bones.rHand     = findBoneByAliases(["righthand","r_hand","mixamorig righthand","mixamorig righthand","mixamorig righthand","mixamorig righthand","mixamorig righthand"]); // harmless
    if (!bones.rHand) bones.rHand = findBoneByAliases(["righthand","r_hand","mixamorigrighthand","j_bip_r_hand"]);

    bones.lUpperLeg = findBoneByAliases(["leftupperleg","l_upperleg","mixamorigleftupleg","j_bip_l_upperleg","leftthigh","upleg"]);
    bones.lLowerLeg = findBoneByAliases(["leftlowerleg","l_lowerleg","mixamorigleftleg","j_bip_l_lowerleg","leftshin","leg"]);
    bones.lFoot     = findBoneByAliases(["leftfoot","l_foot","mixamorigleftfoot","j_bip_l_foot"]);

    bones.rUpperLeg = findBoneByAliases(["rightupperleg","r_upperleg","mixamorigrightupleg","j_bip_r_upperleg","rightthigh"]);
    bones.rLowerLeg = findBoneByAliases(["rightlowerleg","r_lowerleg","mixamorigrightleg","j_bip_r_lowerleg","rightshin"]);
    bones.rFoot     = findBoneByAliases(["rightfoot","r_foot","mixamorigrightfoot","j_bip_r_foot"]);

    // Build missing report
    const must = [
      ["hips","hips"], ["spine","spine"], ["chest","chest"],
      ["lUpperArm","L upperArm"], ["lLowerArm","L lowerArm"],
      ["rUpperArm","R upperArm"], ["rLowerArm","R lowerArm"],
      ["lUpperLeg","L upperLeg"], ["lLowerLeg","L lowerLeg"],
      ["rUpperLeg","R upperLeg"], ["rLowerLeg","R lowerLeg"],
    ];

    const missing = must.filter(([k])=> !bones[k]).map(([,label])=> label);

    let msg = `<b>상태:</b> 아바타 로드 완료<br/>`;
    msg += `<b>스켈레톤:</b> ${skeleton.bones.length} bones 탐지<br/>`;
    if (missing.length){
      msg += `<b>경고:</b> 일부 본 탐지 실패 → <span style="color:#ff8a8a;">${missing.join(", ")}</span><br/>`;
      msg += `<span style="color:rgba(255,255,255,0.72)">본 이름이 특이한 모델이면, 파일을 바꿔보거나(또는 본 이름 규칙을 알려주면) 매핑을 맞춰줄 수 있습니다.</span>`;
      setPill("부분 동작");
    } else {
      msg += `<b>OK:</b> 주요 본 탐지 성공 (길이/폭 조절 가능)`;
      setPill("정상");
    }
    setStatus(msg);
  }

  function applyAdjust(){
    if (!modelGroup || !skeleton) return;

    // Restore to base first (idempotent)
    restoreBaseTransforms();

    const sAll = Number($("S_all").value);
    const sTorso = Number($("S_torso").value);
    const sLeg = Number($("S_leg").value);
    const sArm = Number($("S_arm").value);
    const sShoulderW = Number($("S_shoulderW").value);
    const sHipW = Number($("S_hipW").value);

    // 1) overall scale (uniform)
    modelGroup.scale.set(sAll, sAll, sAll);

    // 2) torso length: scale offsets along spine chain if available
    //    We scale chest offset from spine, and neck/head offsets from chest
    if (bones.spine && bones.chest){
      scaleChildOffset(bones.spine, bones.chest, sTorso);
    } else if (bones.hips && bones.spine){
      scaleChildOffset(bones.hips, bones.spine, sTorso);
    }
    if (bones.chest && bones.neck){
      scaleChildOffset(bones.chest, bones.neck, sTorso);
    }
    if (bones.neck && bones.head){
      scaleChildOffset(bones.neck, bones.head, sTorso);
    }

    // 3) leg length: upperleg->lowerleg and lowerleg->foot
    if (bones.lUpperLeg && bones.lLowerLeg) scaleChildOffset(bones.lUpperLeg, bones.lLowerLeg, sLeg);
    if (bones.lLowerLeg && bones.lFoot)     scaleChildOffset(bones.lLowerLeg, bones.lFoot, sLeg);
    if (bones.rUpperLeg && bones.rLowerLeg) scaleChildOffset(bones.rUpperLeg, bones.rLowerLeg, sLeg);
    if (bones.rLowerLeg && bones.rFoot)     scaleChildOffset(bones.rLowerLeg, bones.rFoot, sLeg);

    // 4) arm length: upperarm->lowerarm and lowerarm->hand
    if (bones.lUpperArm && bones.lLowerArm) scaleChildOffset(bones.lUpperArm, bones.lLowerArm, sArm);
    if (bones.lLowerArm && bones.lHand)     scaleChildOffset(bones.lLowerArm, bones.lHand, sArm);
    if (bones.rUpperArm && bones.rLowerArm) scaleChildOffset(bones.rUpperArm, bones.rLowerArm, sArm);
    if (bones.rLowerArm && bones.rHand)     scaleChildOffset(bones.rLowerArm, bones.rHand, sArm);

    // 5) shoulder width: scale x-offset of upperarms (from base)
    if (bones.lUpperArm) scaleBoneXOffset(bones.lUpperArm, sShoulderW);
    if (bones.rUpperArm) scaleBoneXOffset(bones.rUpperArm, sShoulderW);

    // 6) hip width: scale x-offset of upperlegs (from base)
    if (bones.lUpperLeg) scaleBoneXOffset(bones.lUpperLeg, sHipW);
    if (bones.rUpperLeg) scaleBoneXOffset(bones.rUpperLeg, sHipW);

    // Recenter camera target toward torso
    const hips = bones.hips;
    if (hips){
      const hipsWorld = new THREE.Vector3();
      hips.getWorldPosition(hipsWorld);
      controls.target.lerp(hipsWorld.clone().add(new THREE.Vector3(0, 0.6*sAll, 0)), 0.15);
    }
  }

  // ---------- Load model ----------
  const loader = new GLTFLoader();

  function clearCurrentModel(){
    if (!modelGroup) return;

    scene.remove(modelGroup);
    modelGroup.traverse(o=>{
      if (o.isMesh){
        if (o.geometry) o.geometry.dispose();
        if (Array.isArray(o.material)) o.material.forEach(m=> m.dispose && m.dispose());
        else if (o.material) o.material.dispose && o.material.dispose();
      }
    });

    modelGroup = null;
    skinnedRoot = null;
    skeleton = null;
    bones = {};
    setPill("대기");
    setStatus(`<b>상태:</b> 모델 제거됨`);
  }

  function findFirstSkinnedMesh(root){
    let found = null;
    root.traverse(o=>{
      if (!found && o.isSkinnedMesh && o.skeleton) found = o;
    });
    return found;
  }

  function setupShadows(root){
    root.traverse(o=>{
      if (o.isMesh){
        o.castShadow = true;
        o.receiveShadow = false;
      }
    });
  }

  function frameCameraToModel(root){
    // bbox
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box.getSize(size);
    box.getCenter(center);

    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim * 1.8;

    camera.position.set(center.x + dist*0.65, center.y + dist*0.55, center.z + dist*0.85);
    controls.target.copy(center.add(new THREE.Vector3(0, maxDim*0.15, 0)));
    controls.update();
  }

  async function loadFromUrl(url){
    try{
      setPill("로딩중");
      setStatus(`<b>상태:</b> 로딩중...<br/><span style="color:rgba(255,255,255,0.75)">URL: ${url}</span>`);
      clearCurrentModel();

      const gltf = await loader.loadAsync(url);
      modelGroup = gltf.scene || gltf.scenes?.[0];
      if (!modelGroup) throw new Error("gltf.scene is empty");

      setupShadows(modelGroup);
      modelGroup.position.set(0, 0, 0);
      scene.add(modelGroup);

      skinnedRoot = findFirstSkinnedMesh(modelGroup);
      if (!skinnedRoot || !skinnedRoot.skeleton){
        setPill("주의");
        setStatus(`<b>상태:</b> 모델 로드 완료<br/><b>경고:</b> SkinnedMesh(스켈레톤)를 찾지 못했습니다.<br/>이 기능은 “스켈레톤 포함 GLB”에서만 동작합니다.`);
        frameCameraToModel(modelGroup);
        return;
      }

      skeleton = skinnedRoot.skeleton;
      captureBaseTransforms();
      mapBones();
      frameCameraToModel(modelGroup);

      // apply current sliders
      applyAdjust();

      // autosave sliders
      persistToLocal();
    }catch(err){
      console.error(err);
      setPill("실패");
      setStatus(`<b>상태:</b> 로드 실패<br/><span style="color:#ff8a8a">${String(err.message || err)}</span>`);
    }
  }

  // File pick load
  $("filePick").addEventListener("change", (e)=>{
    const f = e.target.files?.[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    $("modelUrl").value = "(file) " + f.name;
    loadFromUrl(url);
  });

  $("btnLoad").addEventListener("click", ()=>{
    const url = $("modelUrl").value.trim();
    if (!url) return;
    loadFromUrl(url);
  });

  // ---------- Save/Load config ----------
  function readConfig(){
    return {
      S_all: Number($("S_all").value),
      S_torso: Number($("S_torso").value),
      S_leg: Number($("S_leg").value),
      S_arm: Number($("S_arm").value),
      S_shoulderW: Number($("S_shoulderW").value),
      S_hipW: Number($("S_hipW").value),
    };
  }

  function applyConfig(cfg){
    for (const id of sliderIds){
      if (cfg[id] == null) continue;
      $(id).value = cfg[id];
    }
    syncSliderLabels();
    applyAdjust();
    persistToLocal();
  }

  function persistToLocal(){
    try{
      localStorage.setItem("ootmakase_avatar_cfg", JSON.stringify(readConfig()));
    }catch(_){}
  }

  function restoreFromLocal(){
    try{
      const raw = localStorage.getItem("ootmakase_avatar_cfg");
      if (!raw) return;
      const cfg = JSON.parse(raw);
      applyConfig(cfg);
    }catch(_){}
  }

  $("btnSave").addEventListener("click", ()=>{
    const cfg = readConfig();
    const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "ootmakase-avatar-config.json";
    a.click();
    persistToLocal();
  });

  $("btnLoadCfg").addEventListener("click", ()=>{
    const f = $("cfgPick").files?.[0];
    if (!f) { alert("불러올 JSON 파일을 선택하세요."); return; }
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const cfg = JSON.parse(reader.result);
        applyConfig(cfg);
      }catch(e){
        alert("JSON 형식이 올바르지 않습니다.");
      }
    };
    reader.readAsText(f);
  });

  $("btnReset").addEventListener("click", ()=>{
    $("S_all").value = 1.00;
    $("S_torso").value = 1.00;
    $("S_leg").value = 1.00;
    $("S_arm").value = 1.00;
    $("S_shoulderW").value = 1.00;
    $("S_hipW").value = 1.00;
    syncSliderLabels();
    applyAdjust();
    persistToLocal();
  });

  // live update sliders
  let t = null;
  for (const id of sliderIds){
    $(id).addEventListener("input", ()=>{
      syncSliderLabels();
      clearTimeout(t);
      t = setTimeout(()=>{ applyAdjust(); persistToLocal(); }, 30);
    });
  }

  // ---------- Render loop ----------
  function resize(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  addEventListener("resize", resize);

  function loop(){
    requestAnimationFrame(loop);
    resize();
    controls.update();
    renderer.render(scene, camera);
  }
  loop();

  // ---------- Boot ----------
  restoreFromLocal();          // slider config restore
  loadFromUrl($("modelUrl").value.trim());   // auto load default
</script>
</body>
</html>
